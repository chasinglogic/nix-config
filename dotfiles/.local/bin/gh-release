#!/usr/bin/env python3

import argparse
import json
import os
import re
import sys
from copy import deepcopy
from subprocess import check_output

import requests


class Version:
    """A semver object."""

    release_ver = re.compile(r"^(v)?[0-9]+\.[0-9]+\.[0-9]+(-[A-z0-9]+)?$")

    def __init__(self, major, minor, patch, suffix=None, use_v_prefix=False):
        self.major = major
        self.minor = minor
        self.patch = patch
        self.suffix = suffix
        self.use_v_prefix = use_v_prefix

    @staticmethod
    def is_version_string(verstr):
        return bool(Version.release_ver.match(verstr))

    @classmethod
    def from_str(cls, verstr):
        if not Version.is_version_string(verstr):
            raise Exception("Got unexpected input: {verstr}".format(verstr=verstr))

        major, minor, patch = verstr.split(".")
        suffix = None
        if "-" in patch:
            patch, suffix = patch.split("-")

        use_v_prefix = False
        if major.startswith("v"):
            major = major[1:]
            use_v_prefix = True

        return cls(
            int(major),
            int(minor),
            int(patch),
            suffix,
            use_v_prefix=use_v_prefix,
        )

    def increment_patch(self):
        self.patch += 1

    def increment_minor(self):
        self.minor += 1
        self.patch = 0

    def increment_major(self):
        self.major += 1
        self.minor = 0
        self.patch = 0

    def __str__(self):
        return "{prefix}{major}.{minor}.{patch}{suffix}".format(
            major=self.major,
            minor=self.minor,
            patch=self.patch,
            suffix="-" + self.suffix if self.suffix else "",
            prefix="v" if self.use_v_prefix else "",
        )

    def __eq__(self, other):
        if not isinstance(other, Version):
            return False

        return (
            self.major == other.major
            and self.minor == other.minor
            and self.patch == other.patch
            and self.suffix == other.suffix
        )

    def __lt__(self, other):
        for version_part in ["major", "minor", "patch"]:
            ours = getattr(self, version_part)
            theirs = getattr(other, version_part)
            if ours > theirs:
                return False

            if theirs > ours:
                return True

            # Same version part value

        if self.suffix == other.suffix:
            return False

        suffix_precedence = {
            "beta": -1,
            "tc": 0,
            "rc": 1,
            None: 2,
        }

        our_suffix = suffix_precedence.get(self.suffix, -2)
        their_suffix = suffix_precedence.get(other.suffix, -2)
        return our_suffix < their_suffix

    def __le__(self, other):
        return self == other or self < other


def git(*args):
    cmd = ["git"]
    cmd.extend(args)
    return check_output(cmd).decode("utf-8")


def get_repo():
    remotes = check_output(["git", "remote", "-v"]).decode("utf-8").split("\n")
    for remote in remotes:
        if not remote:
            continue

        first_segment, _ = remote.split(" ")
        _, url = first_segment.split("\t")

        if "github.com" not in url:
            continue

        if url.startswith("ssh") or url.startswith("git@"):
            return url.split(":")[-1]
        else:
            return "/".join(url.split("/")[-2:])


def get_last_version():
    versions = [
        Version.from_str(ver[len("refs/tags/") :])
        for ver in (
            check_output(
                [
                    "git",
                    "for-each-ref",
                    "--sort=-taggerdate",
                    "--format",
                    "%(refname)",
                    "refs/tags",
                ]
            )
            .decode("utf-8")
            .split("\n")
        )
        if ver[len("refs/tags/") :]
    ]
    if not versions:
        return Version(0, 0, 0)

    return sorted(versions)[-1]


def get_commit_for_tag(tag):
    return (
        check_output(["git", "show", "--no-patch", "--pretty=%H", tag])
        .decode("utf-8")
        .strip()
    )


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        '--version',
        '-v',
        type=str,
        default='',
        help='Specify the version to go to',
    )
    parser.add_argument(
        "--pre-release",
        "-l",
        action="store_true",
        help="Indicates this is a pre-release",
    )
    parser.add_argument(
        "--draft",
        "-d",
        action="store_true",
        help="Indicates this is a draft release",
    )
    parser.add_argument(
        "--repo",
        "-r",
        type=str,
        default=get_repo(),
        help="The repository to create the release on in :owner/:repo format, "
        "will attempt to parse from git remotes if not given",
    )
    parser.add_argument(
        "--title",
        "-t",
        action="store_true",
        help="If given use the release name as the markdown title, otherwise title "
        "is omitted for Github style formatting",
    )
    parser.add_argument(
        "--minor",
        "-m",
        action="store_true",
        help="Bump by minor",
    )
    parser.add_argument(
        "--major",
        "-j",
        action="store_true",
        help="Bump by major",
    )
    parser.add_argument(
        "--patch",
        "-p",
        action="store_true",
        help="Bump by patch",
    )
    args = parser.parse_args()

    if not any((args.patch, args.minor, args.major, args.version)):
        print("Must provide one of --version, --major, --minor, or --patch.")
        sys.exit(1)

    token = os.getenv("GITHUB_TOKEN")
    if not token:
        print("$GITHUB_TOKEN must be set.")
        sys.exit(1)

    last_version = get_last_version()
    if last_version == Version(0, 0, 0):
        commits = git("log", "--reverse", "--format=%H").split("\n")
        # Initial commit to the branch / repository
        last_version_commit = commits[0]
    else:
        last_version_commit = get_commit_for_tag(str(last_version))

    version_commit = get_commit_for_tag("HEAD")

    if args.version:
        version = Version.from_str(args.version)
    else:
        version = deepcopy(last_version)
        if args.patch:
            version.increment_patch()
        if args.minor:
            version.increment_minor()
        if args.major:
            version.increment_major()

    messages = check_output(
        [
            "git",
            "log",
            "--pretty=format:%h %s",
            f"{last_version_commit}...{version_commit}",
        ],
    ).decode("utf-8")
    changelog = "\n".join(
        [
            f"- {message}"
            for message in messages.split("\n")
            if message
            and not message.endswith(f"release: {version}")
            and "Merge pull request" not in message
        ],
    )

    emails = check_output(
        [
            "git",
            "log",
            "--pretty=format:%an <%ae>",
            f"{last_version_commit}...{version_commit}",
        ],
    ).decode("utf-8")
    contributors = "\n".join({f"- {email}" for email in emails.split("\n") if email})

    if args.title:
        release_notes = f"# Release {version}\n\n"
    else:
        release_notes = ""

    release_notes += (
        f"{changelog}\n\n## Contributors to this Release\n\n{contributors}\n"
    )

    body = {
        "tag_name": str(version),
        "name": str(version),
        "body": release_notes,
        "draft": args.draft,
        "prerelease": args.pre_release,
    }

    headers = {
        "Authorization": f"token {token}",
        "Accept": "application/vnd.github.v3+json",
    }

    print("Creating release", version, version_commit)
    print("Previous version", last_version, last_version_commit)
    print("Pre-release?", args.pre_release)
    print("Draft release?", args.draft)
    print("Repository", args.repo)
    print("============= Release Notes ============")
    print(release_notes)

    ans = input("Does this look correct? (y/N) ")
    if not ans.startswith("y"):
        return

    if os.path.isfile("package.json"):
        with open("package.json") as pkg_json_file:
            pkg_json = json.loads(pkg_json_file.read())
            pkg_json["version"] = str(version)

        with open("package.json", "w") as pkg_json_file:
            json.dump(
                pkg_json,
                pkg_json_file,
                indent=4,
            )

        git("add", "package.json")
        git("commit", "-m", f"release: {version}")
        git("push")

    git("tag", str(version))
    git("push", "--tags")
    response = requests.post(
        f"https://api.github.com/repos/{args.repo}/releases",
        headers=headers,
        json=body,
    )
    try:
        response.raise_for_status()
    except Exception as exc:
        print("Failed to create release!")
        print(exc)
        print(f"{response.text}")


if __name__ == "__main__":
    main()
